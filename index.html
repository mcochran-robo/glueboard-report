<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Glueboard Report</title>
    <style>
      body { font-family: system-ui, sans-serif; max-width: 980px; margin: 24px auto; padding: 0 14px; }
      h1 { margin: 0 0 6px; }
      .sub { color:#666; margin: 0 0 18px; }
      input, button { font-size: 16px; padding: 10px; }
      input { width: 100%; box-sizing: border-box; margin: 8px 0 12px; }
      button { cursor: pointer; }
      .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-top: 14px; }
      .card { border: 1px solid #e6e6e6; border-radius: 12px; padding: 14px; background: #fff; }
      .big { font-size: 56px; font-weight: 800; line-height: 1; letter-spacing: -0.02em; }
      .label { color:#666; margin-top: 6px; font-size: 14px; }
      .warn { border: 2px solid #c62828; background:#ffebee; }
      .ok { border: 2px solid #2e7d32; background:#e8f5e9; }
      .warn-title { font-weight: 800; color:#b71c1c; margin:0 0 6px; }
      .ok-title { font-weight: 800; color:#1b5e20; margin:0 0 6px; }
      ul { margin: 8px 0 0 18px; }
      pre { background:#f6f6f6; padding: 12px; overflow:auto; border-radius: 10px; }
      .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
      .muted { color:#666; font-size: 13px; }
      .hidden { display:none; }
      @media (max-width: 760px) { .grid { grid-template-columns: 1fr; } .big { font-size: 46px; } }
    </style>
  </head>
  <body>
    <h1>Glueboard Report</h1>
    <p class="sub">Paste an image URL, run the workflow, and view a summarized report.</p>

    <input id="imageUrl" placeholder="https://.../image.jpg" />
    <div class="row">
      <button id="run">Run Analysis</button>
      <span id="status" class="muted"></span>
    </div>

    <div class="grid">
      <div class="card" id="coverageCard">
        <div class="big" id="coveragePct">—%</div>
        <div class="label">Glueboard coverage</div>
        <div class="muted" id="coverageNote"></div>
      </div>

      <div class="card" id="iocCard">
        <div id="iocState">
          <div class="warn-title">⚠️ Insects of Concern Detected</div>
          <div class="muted">Total matches across all segments:</div>
          <div class="big" id="iocCount">0</div>
        </div>

        <div id="iocListWrap" class="hidden">
          <div class="label">Insects of concern (unique)</div>
          <ul id="iocList"></ul>
        </div>
      </div>
    </div>

    <details style="margin-top:14px;">
      <summary>Raw workflow response</summary>
      <pre id="raw">{}</pre>
    </details>

    <script>
      // === CONFIG ===
      const WORKFLOW_URL = "https://serverless.roboflow.com/vision-project-0y4uc/workflows/sam3-with-prompts-2";
      const API_KEY = "Y7AWCmC4VdWbClU92tVw"; // visible on GitHub Pages (trusted users only)

      const DEFAULT_PROMPTS = ["glueboard","insects","fly","gnat","bug","Beetle","moth"];

      // If your workflow outputs live under result.outputs or result.results etc,
      // this helper will find them by searching keys.
      function deepGet(obj, path) {
        return path.split(".").reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj);
      }

      function findFirst(obj, candidates) {
        for (const p of candidates) {
          const v = deepGet(obj, p);
          if (v !== undefined) return v;
        }
        return undefined;
      }

      // Flatten list-of-lists like [[], ["x"], [], ["y"]]
      function flattenStrings(value) {
        const out = [];
        if (Array.isArray(value)) {
          for (const item of value) {
            if (Array.isArray(item)) out.push(...item.filter(s => typeof s === "string" && s.trim()));
            else if (typeof item === "string" && item.trim()) out.push(item);
          }
        } else if (typeof value === "string" && value.trim()) {
          out.push(value);
        }
        return out;
      }

      function uniqPreserveOrder(arr) {
        const seen = new Set();
        const out = [];
        for (const s of arr) {
          if (!seen.has(s)) { seen.add(s); out.push(s); }
        }
        return out;
      }

      function sumNumbers(value) {
        if (Array.isArray(value)) {
          return value.reduce((acc, x) => acc + (typeof x === "number" ? x : 0), 0);
        }
        return typeof value === "number" ? value : 0;
      }

      // === UI helpers ===
      function setCoverage(pct) {
        const el = document.getElementById("coveragePct");
        const note = document.getElementById("coverageNote");

        if (typeof pct !== "number" || !isFinite(pct)) {
          el.textContent = "—%";
          note.textContent = "";
          return;
        }
        el.textContent = `${pct.toFixed(1)}%`;
        note.textContent = pct > 0 ? "Higher % means more surface covered by detected insects." : "";
      }

      function setIOC(totalCount, uniqueList) {
        const card = document.getElementById("iocCard");
        const countEl = document.getElementById("iocCount");
        const listWrap = document.getElementById("iocListWrap");
        const listEl = document.getElementById("iocList");
        const stateTitle = document.querySelector("#iocState > div:first-child");

        countEl.textContent = String(totalCount);

        // Style + title
        if (totalCount > 0) {
          card.classList.remove("ok");
          card.classList.add("warn");
          stateTitle.textContent = "⚠️ Insects of Concern Detected";
          stateTitle.className = "warn-title";
        } else {
          card.classList.remove("warn");
          card.classList.add("ok");
          stateTitle.textContent = "✅ No Insects of Concern";
          stateTitle.className = "ok-title";
        }

        // Unique list
        listEl.innerHTML = "";
        if (uniqueList.length > 0) {
          listWrap.classList.remove("hidden");
          for (const item of uniqueList) {
            const li = document.createElement("li");
            li.textContent = item;
            listEl.appendChild(li);
          }
        } else {
          listWrap.classList.add("hidden");
        }
      }

      // === Main ===
      document.getElementById("run").onclick = async () => {
        const imageUrl = document.getElementById("imageUrl").value.trim();
        const statusEl = document.getElementById("status");
        const rawEl = document.getElementById("raw");

        if (!imageUrl) {
          statusEl.textContent = "Please paste an image URL.";
          return;
        }

        statusEl.textContent = "Running...";
        rawEl.textContent = "{}";
        setCoverage(undefined);
        setIOC(0, []);

        try {
          const response = await fetch(WORKFLOW_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              api_key: API_KEY,
              inputs: {
                image: { type: "url", value: imageUrl },
                prompts: DEFAULT_PROMPTS
              }
            })
          });

          const result = await response.json();
          rawEl.textContent = JSON.stringify(result, null, 2);

          // ---- PATHS: adjust if your workflow nests differently ----
          // Try common locations for your final/aggregated outputs:
          const coverageCandidatePaths = [
            "coverage_pct",
            "outputs.coverage_pct",
            "result.coverage_pct",
            "results.coverage_pct",
            "outputs.total_coverage_pct",
            "outputs.glueboard_coverage_pct",
          ];

          const iocCountPaths = [
            "total_insects_of_concern",
            "outputs.total_insects_of_concern",
            "outputs.insects_of_concern_count",
            "insects_of_concern_count",
          ];

          const iocListPaths = [
            "unique_insects_of_concern",
            "outputs.unique_insects_of_concern",
            "outputs.insects_of_concern",
            "insects_of_concern",
          ];

          // Grab values (may be float/int or list-of-values)
          let coveragePct = findFirst(result, coverageCandidatePaths);

          // If coverage is present as a string like "37.5", coerce
          if (typeof coveragePct === "string") {
            const n = Number(coveragePct);
            coveragePct = Number.isFinite(n) ? n : undefined;
          }

          // IOC count might be list[int] (per segment) or already aggregated int
          let iocCount = findFirst(result, iocCountPaths);
          const totalIOC = sumNumbers(iocCount);

          // IOC list might be list-of-lists or string
          let iocList = findFirst(result, iocListPaths);
          const flat = flattenStrings(iocList);
          const unique = uniqPreserveOrder(flat);

          setCoverage(coveragePct);
          setIOC(totalIOC, unique);

          statusEl.textContent = response.ok ? "Done." : "Error (see raw response).";
        } catch (err) {
          statusEl.textContent = "Network error.";
          rawEl.textContent = String(err);
        }
      };
    </script>
  </body>
</html>
